<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>多线程能力 | 青春小火车车站</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="简介应用中的每个进程都会有一个主线程，主线程主要承担执行UI绘制操作、管理ArkTS引擎实例的创建和销毁、分发和处理事件、管理Ability生命周期等职责，具体可参见线程模型概述。因此，开发应用时应当尽量避免将耗时的操作放在主线程中执行。ArkTS提供了Worker和TaskPool两种多线程并发能力。 鸿蒙系统中Worker和TaskPool都是基于Actor并发模型实现的并发能力。  Acto">
<meta property="og:type" content="article">
<meta property="og:title" content="多线程能力">
<meta property="og:url" content="https://qcxhc.github.io/2024/04/25/%E9%B8%BF%E8%92%99/%E5%A4%9A%E7%BA%BF%E7%A8%8B/index.html">
<meta property="og:site_name" content="青春小火车车站">
<meta property="og:description" content="简介应用中的每个进程都会有一个主线程，主线程主要承担执行UI绘制操作、管理ArkTS引擎实例的创建和销毁、分发和处理事件、管理Ability生命周期等职责，具体可参见线程模型概述。因此，开发应用时应当尽量避免将耗时的操作放在主线程中执行。ArkTS提供了Worker和TaskPool两种多线程并发能力。 鸿蒙系统中Worker和TaskPool都是基于Actor并发模型实现的并发能力。  Acto">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2024-04-25T04:32:35.000Z">
<meta property="article:modified_time" content="2024-04-25T05:12:00.620Z">
<meta property="article:author" content="青春小火车">
<meta property="article:tag" content="鸿蒙">
<meta property="article:tag" content="并发">
<meta property="article:tag" content="多线程">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="青春小火车车站" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<meta name="generator" content="Hexo 7.1.1"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">青春小火车车站</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS 订阅"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="搜索"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="搜索"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://qcxhc.github.io"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-鸿蒙/多线程" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/04/25/%E9%B8%BF%E8%92%99/%E5%A4%9A%E7%BA%BF%E7%A8%8B/" class="article-date">
  <time class="dt-published" datetime="2024-04-25T04:32:35.000Z" itemprop="datePublished">2024-04-25</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="p-name article-title" itemprop="headline name">
      多线程能力
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>应用中的每个进程都会有一个主线程，主线程主要承担执行UI绘制操作、管理ArkTS引擎实例的创建和销毁、分发和处理事件、管理Ability生命周期等职责，具体可参见线程模型概述。因此，开发应用时应当尽量避免将耗时的操作放在主线程中执行。ArkTS提供了Worker和TaskPool两种多线程并发能力。</p>
<p>鸿蒙系统中Worker和TaskPool都是基于Actor并发模型实现的并发能力。</p>
<blockquote>
<p>Actor需要明确指定消息接收方，而CSP中处理单元不用关心这些，只需要把消息发送给Channel，而接收方只需要从Channel读取消息。</p>
</blockquote>
<blockquote>
<p>由于在默认情况下Channel是没有缓存的，因此对Channel的发送（Send）动作是同步阻塞的，直到另外一个持有该Channel引用的执行块取出消息，而Actor模型中信箱本质是队列，因此消息的发送和接收可以是异步的。</p>
</blockquote>
<h2 id="Worker"><a href="#Worker" class="headerlink" title="Worker"></a>Worker</h2><p>Worker是一个独立的线程。Worker拥有独立的运行环境，每个Worker线程和主线程一样拥有自己的内存空间、消息队列（MessageQueue）、事件轮询机制（EventLoop）、调用栈（CallStack）等。线程之间通过消息（Massage）进行交互。</p>
<h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><ul>
<li><p>运行时间超过3分钟的任务，需要使用Worker。</p>
</li>
<li><p>有关联的一系列同步任务，例如数据库增、删、改、查等，要保证同一个句柄，需要使用Worker。</p>
</li>
</ul>
<h3 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h3><p>1、宿主线程创建一个Worker线程。通过new worker.ThreadWorker()创建Worker实例，示例代码如下：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 引入worker模块</span></span><br><span class="line"><span class="keyword">import</span> worker, &#123; <span class="title class_">MessageEvents</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;@ohos.worker&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">type</span> common <span class="keyword">from</span> <span class="string">&#x27;@ohos.app.ability.common&#x27;</span>;</span><br><span class="line">        </span><br><span class="line"><span class="keyword">let</span> <span class="attr">workerInstance</span>: worker.<span class="property">ThreadWorker</span> = <span class="keyword">new</span> worker.<span class="title class_">ThreadWorker</span>(<span class="string">&#x27;entry/ets/pages/workers/worker.ts&#x27;</span>, &#123; </span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;FriendsMoments Worker&#x27;</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>2、宿主线程给Worker线程发送任务消息。宿主线程通过postMessage方法来发送消息给Worker线程，启动下载解压任务，示例代码如下</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 请求网络数据</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">context</span>: common.<span class="property">UIAbilityContext</span> = <span class="title function_">getContext</span>(<span class="variable language_">this</span>) <span class="keyword">as</span> common.<span class="property">UIAbilityContext</span>;</span><br><span class="line"><span class="comment">// 参数中mediaData和isImageData是根据开发者自己的业务需求添加的，其中mediaData为数据路径、isImageData为判断图片或视频的标识</span></span><br><span class="line">workerInstance.<span class="title function_">postMessage</span>(&#123; context, <span class="attr">mediaData</span>: <span class="variable language_">this</span>.<span class="property">mediaData</span>, <span class="attr">isImageData</span>: <span class="variable language_">this</span>.<span class="property">isImageData</span> &#125;);</span><br></pre></td></tr></table></figure>

<p>3、Worker线程监听宿主线程发送的消息。Worker线程在onmessage中接收到宿主线程的postMessage请求，执行下载解压任务，示例代码如下：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 引入worker模块</span></span><br><span class="line"><span class="keyword">import</span> worker, &#123; <span class="title class_">MessageEvents</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;@ohos.worker&#x27;</span>;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">let</span> workerPort = worker.<span class="property">workerPort</span>;</span><br><span class="line"><span class="comment">// 接收宿主线程的postMessage请求</span></span><br><span class="line">workerPort.<span class="property">onmessage</span> = (<span class="attr">e</span>: <span class="title class_">MessageEvents</span>): <span class="function"><span class="params">void</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 下载视频文件</span></span><br><span class="line">  <span class="keyword">let</span> <span class="attr">context</span>: common.<span class="property">UIAbilityContext</span> = e.<span class="property">data</span>.<span class="property">context</span>;</span><br><span class="line">  <span class="keyword">let</span> <span class="attr">filesDir</span>: <span class="built_in">string</span> = context.<span class="property">filesDir</span>;</span><br><span class="line">  <span class="keyword">let</span> <span class="attr">time</span>: <span class="built_in">number</span> = <span class="keyword">new</span> <span class="title class_">Date</span>().<span class="title function_">getTime</span>();</span><br><span class="line">  <span class="keyword">let</span> <span class="attr">inFilePath</span>: <span class="built_in">string</span> = <span class="string">`<span class="subst">$&#123;filesDir&#125;</span>/<span class="subst">$&#123;time.toString()&#125;</span>.zip`</span>;</span><br><span class="line">  <span class="keyword">let</span> <span class="attr">mediaDataUrl</span>: <span class="built_in">string</span> = e.<span class="property">data</span>.<span class="property">mediaData</span>;</span><br><span class="line">  <span class="keyword">let</span> <span class="attr">urlPart</span>: <span class="built_in">string</span> = mediaDataUrl.<span class="title function_">split</span>(<span class="string">&#x27;.&#x27;</span>)[<span class="number">1</span>];</span><br><span class="line">  <span class="keyword">let</span> <span class="attr">length</span>: <span class="built_in">number</span> = urlPart.<span class="title function_">split</span>(<span class="string">&#x27;/&#x27;</span>).<span class="property">length</span>;</span><br><span class="line">  <span class="keyword">let</span> <span class="attr">fileName</span>: <span class="built_in">string</span> = urlPart.<span class="title function_">split</span>(<span class="string">&#x27;/&#x27;</span>)[length-<span class="number">1</span>];</span><br><span class="line">  <span class="keyword">let</span> <span class="attr">options</span>: zlib.<span class="property">Options</span> = &#123;</span><br><span class="line">    <span class="attr">level</span>: zlib.<span class="property">CompressLevel</span>.<span class="property">COMPRESS_LEVEL_DEFAULT_COMPRESSION</span></span><br><span class="line">  &#125;;</span><br><span class="line">  request.<span class="title function_">downloadFile</span>(context, &#123;</span><br><span class="line">    <span class="attr">url</span>: mediaDataUrl,</span><br><span class="line">    <span class="attr">filePath</span>: inFilePath</span><br><span class="line">  &#125;).<span class="title function_">then</span>(<span class="function">(<span class="params">downloadTask</span>) =&gt;</span> &#123;</span><br><span class="line">    downloadTask.<span class="title function_">on</span>(<span class="string">&#x27;progress&#x27;</span>, <span class="function">(<span class="params">receivedSize: <span class="built_in">number</span>, totalSize: <span class="built_in">number</span></span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="title class_">Logger</span>.<span class="title function_">info</span>(<span class="string">`receivedSize:<span class="subst">$&#123;receivedSize&#125;</span>,totalSize:<span class="subst">$&#123;totalSize&#125;</span>`</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    downloadTask.<span class="title function_">on</span>(<span class="string">&#x27;complete&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 下载完成之后执行解压操作</span></span><br><span class="line">      zlib.<span class="title function_">decompressFile</span>(inFilePath, filesDir, options, <span class="function">(<span class="params">errData: BusinessError</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (errData !== <span class="literal">null</span>) &#123;</span><br><span class="line">          ...</span><br><span class="line">          <span class="comment">// 异常处理</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">let</span> <span class="attr">videoPath</span>: <span class="built_in">string</span> = <span class="string">`<span class="subst">$&#123;filesDir&#125;</span>/<span class="subst">$&#123;fileName&#125;</span>/<span class="subst">$&#123;fileName&#125;</span>.mp4`</span>;</span><br><span class="line">        workerPort.<span class="title function_">postMessage</span>(&#123; <span class="string">&#x27;isComplete&#x27;</span>: <span class="literal">true</span>, <span class="string">&#x27;filePath&#x27;</span>: videoPath &#125;);</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;);</span><br><span class="line">    downloadTask.<span class="title function_">on</span>(<span class="string">&#x27;fail&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      ...</span><br><span class="line">      <span class="comment">// 异常处理</span></span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;).<span class="title function_">catch</span>(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 异常处理</span></span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>4、宿主线程监听Worker线程发送的信息。宿主线程通过onmessage接收到Worker线程发送的消息，并执行下载的结果通知。</p>
<p>5、释放Worker资源。在业务完成或者页面销毁时，调用workerPort.close()接口主动释放Worker资源，示例代码如下所示：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">workerInstance.<span class="property">onmessage</span> = (<span class="attr">e</span>: <span class="title class_">MessageEvents</span>): <span class="function"><span class="params">void</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (e.<span class="property">data</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">downComplete</span> = e.<span class="property">data</span>[<span class="string">&#x27;isComplete&#x27;</span>];</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">filePath</span> = e.<span class="property">data</span>[<span class="string">&#x27;filePath&#x27;</span>];</span><br><span class="line">    workerInstance.<span class="title function_">terminate</span>();</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">downloadStatus</span> = <span class="literal">false</span>;</span><br><span class="line">    &#125;, <span class="variable constant_">LOADING_DURATION_OPEN</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="TaskPool"><a href="#TaskPool" class="headerlink" title="TaskPool"></a>TaskPool</h3><p>相比使用Worker实现多线程并发，TaskPool更加易于使用，创建开销也少于Worker，并且Worker线程有个数限制，需要开发者自己掌握。TaskPool作用是为应用程序提供一个多线程的运行环境。TaskPool在Worker之上实现了调度器和Worker线程池，TaskPool根据任务的优先级，将其放入不同的优先级队列，调度器会依据自己实现的调度算法（优先级，防饥饿），从优先级队列中取出任务，放入TaskPool中的Worker线程池，执行相关任务。</p>
<h3 id="TaskPool特点"><a href="#TaskPool特点" class="headerlink" title="TaskPool特点"></a>TaskPool特点</h3><ul>
<li><p>轻量化的并行机制。</p>
</li>
<li><p>降低整体资源的消耗。</p>
</li>
<li><p>提高系统的整体性能。</p>
</li>
<li><p>无需关心线程实例的生命周期。</p>
</li>
<li><p>可以使用TaskPool API创建后台任务（Task），并对所创建的任务进行如任务执行、任务取消的操作。</p>
</li>
<li><p>根据任务负载动态调节TaskPool工作线程的数量，以使任务按照预期时间完成任务。</p>
</li>
<li><p>可以设置任务的优先级。</p>
</li>
<li><p>可以设置任务组（TaskGroup）将任务关联起来。</p>
</li>
</ul>
<h3 id="使用场景-1"><a href="#使用场景-1" class="headerlink" title="使用场景"></a>使用场景</h3><ul>
<li><p>需要设置优先级的任务。</p>
</li>
<li><p>需要频繁取消的任务。</p>
</li>
<li><p>大量或者调度点较分散的任务。</p>
</li>
</ul>
<h3 id="使用方法-1"><a href="#使用方法-1" class="headerlink" title="使用方法"></a>使用方法</h3><p>1、首先import引入TaskPool模块。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> taskpool <span class="keyword">from</span> <span class="string">&#x27;@ohos.taskpool&#x27;</span>;</span><br><span class="line">typescript</span><br><span class="line"><span class="keyword">import</span> taskpool <span class="keyword">from</span> <span class="string">&#x27;@ohos.taskpool&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p>2、new一个task对象，其中传入被调用的方法和参数。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建task任务项，参数1.任务执行需要传入函数 参数2.任务执行传入函数的参数 （本示例中此参数为被调用的网络地址字符串）</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">task</span>: taskpool.<span class="property">Task</span> = <span class="keyword">new</span> taskpool.<span class="title class_">Task</span>(getWebData, jsonUrl);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取网络数据</span></span><br><span class="line"><span class="meta">@Concurrent</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">getWebData</span>(<span class="params">url: <span class="built_in">string</span></span>): <span class="title class_">Promise</span>&lt;<span class="title class_">Array</span>&lt;<span class="title class_">FriendMoment</span>&gt;&gt; &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="attr">webData</span>: http.<span class="property">HttpResponse</span> = <span class="keyword">await</span> http.<span class="title function_">createHttp</span>().<span class="title function_">request</span>(</span><br><span class="line">      url,</span><br><span class="line">      &#123; <span class="attr">header</span>: &#123;</span><br><span class="line">          <span class="string">&#x27;Content-Type&#x27;</span>: <span class="string">&#x27;application/json&#x27;</span></span><br><span class="line">      &#125;,</span><br><span class="line">        <span class="attr">connectTimeout</span>: <span class="number">60000</span>, <span class="attr">readTimeout</span>: <span class="number">60000</span></span><br><span class="line">      &#125;)</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> (webData.<span class="property">result</span>) === <span class="string">&#x27;string&#x27;</span>) &#123;</span><br><span class="line">      <span class="comment">// 解析json字符串</span></span><br><span class="line">      <span class="keyword">let</span> <span class="attr">jsonObj</span>: <span class="title class_">Array</span>&lt;<span class="title class_">FriendMoment</span>&gt; = <span class="keyword">await</span> <span class="title class_">JSON</span>.<span class="title function_">parse</span>(webData.<span class="property">result</span>).<span class="property">FriendMoment</span>;</span><br><span class="line">      <span class="keyword">let</span> <span class="attr">friendMomentBuckets</span>: <span class="title class_">Array</span>&lt;<span class="title class_">FriendMoment</span>&gt; = <span class="keyword">new</span> <span class="title class_">Array</span>&lt;<span class="title class_">FriendMoment</span>&gt;();</span><br><span class="line">      <span class="comment">// 下方源码省略，主要为数据解析和耗时操作处理</span></span><br><span class="line">      ...</span><br><span class="line">      <span class="keyword">return</span> friendMomentBuckets;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 异常处理</span></span><br><span class="line">      ...</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">    <span class="comment">// 异常处理</span></span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3、之后使用taskpool.execute执行TaskPool任务，将待执行的函数放入TaskPool内部任务队列等待执行。execute需要两个参数：创建的任务对象、等待执行的任务组的优先级，默认值是Priority.MEDIUM。在TaskPool中执行完数据下载、解析和处理后，再返回给主线程中。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">friendMomentArray</span>: <span class="title class_">Array</span>&lt;<span class="title class_">FriendMoment</span>&gt; = <span class="keyword">await</span> taskpool.<span class="title function_">execute</span>(task, taskpool.<span class="property">Priority</span>.<span class="property">MEDIUM</span>) <span class="keyword">as</span> <span class="title class_">Array</span>&lt;<span class="title class_">FriendMoment</span>&gt;;</span><br><span class="line">typescript</span><br><span class="line"><span class="keyword">let</span> <span class="attr">friendMomentArray</span>: <span class="title class_">Array</span>&lt;<span class="title class_">FriendMoment</span>&gt; = <span class="keyword">await</span> taskpool.<span class="title function_">execute</span>(task, taskpool.<span class="property">Priority</span>.<span class="property">MEDIUM</span>) <span class="keyword">as</span> <span class="title class_">Array</span>&lt;<span class="title class_">FriendMoment</span>&gt;;</span><br></pre></td></tr></table></figure>
<p>4、将新获取的momentData通过AppStorage.setOrCreate传入页面组件中。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取页面组件中的momentData对象，其中是组件所需的username、image、video等数据</span></span><br><span class="line"><span class="keyword">let</span> momentData = <span class="title class_">AppStorage</span>.<span class="property">get</span>&lt;<span class="title class_">FriendMomentsData</span>&gt;(<span class="string">&#x27;momentData&#x27;</span>);</span><br><span class="line"><span class="comment">// 循环遍历对象并依次传入momentData</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; friendMomentArray.<span class="property">length</span>; i++) &#123;</span><br><span class="line">  momentData.<span class="title function_">pushData</span>(friendMomentArray[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 将更新的momentData返回给页面组件</span></span><br><span class="line"><span class="title class_">AppStorage</span>.<span class="title function_">setOrCreate</span>(<span class="string">&#x27;momentData&#x27;</span>, momentData);</span><br></pre></td></tr></table></figure>

<h2 id="Worker和TaskPool实现特点对比"><a href="#Worker和TaskPool实现特点对比" class="headerlink" title="Worker和TaskPool实现特点对比"></a>Worker和TaskPool实现特点对比</h2><table>
<thead>
<tr>
<th align="left">实现</th>
<th>TaskPool</th>
<th>Worker</th>
</tr>
</thead>
<tbody><tr>
<td align="left">线程隔离</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td align="left">内存模型</td>
<td>线程间隔离，内存不共享。</td>
<td>线程间隔离，内存不共享。</td>
</tr>
<tr>
<td align="left">参数传递机制</td>
<td>采用标准的结构化克隆算法（Structured Clone）进行序列化、反序列化，完成参数传递。 支持ArrayBuffer转移和SharedArrayBuffer共享。</td>
<td>采用标准的结构化克隆算法（Structured Clone）进行序列化、反序列化，完成参数传递。 支持ArrayBuffer转移和SharedArrayBuffer共享。</td>
</tr>
<tr>
<td align="left">参数传递</td>
<td>直接传递，无需封装，默认进行transfer。</td>
<td>消息对象唯一参数，需要自己封装。</td>
</tr>
<tr>
<td align="left">方法调用</td>
<td>直接将方法传入调用。</td>
<td>在Worker线程中进行消息解析并调用对应方法。</td>
</tr>
<tr>
<td align="left">返回值</td>
<td>异步调用后默认返回。</td>
<td>主动发送消息，需在onmessage解析赋值。</td>
</tr>
<tr>
<td align="left">生命周期</td>
<td>TaskPool自行管理生命周期，无需关心任务负载高低。</td>
<td>开发者自行管理Worker的数量及生命周期。</td>
</tr>
<tr>
<td align="left">任务池个数上限</td>
<td>自动管理，无需配置。</td>
<td>同个进程下，最多支持同时开启8个Worker线程。</td>
</tr>
<tr>
<td align="left">任务执行时长上限</td>
<td>3分钟（不包含Promise和async&#x2F;await异步调用的耗时，例如网络下载、文件读写等I&#x2F;O任务的耗时）。</td>
<td>无限制。</td>
</tr>
<tr>
<td align="left">设置任务的优先级</td>
<td>支持配置任务优先级。</td>
<td>不支持。</td>
</tr>
<tr>
<td align="left">执行任务的取消</td>
<td>支持取消已经发起的任务。</td>
<td>不支持。</td>
</tr>
<tr>
<td align="left">线程复用</td>
<td>支持。</td>
<td>不支持。</td>
</tr>
<tr>
<td align="left">任务延时执行</td>
<td>支持。</td>
<td>不支持。</td>
</tr>
<tr>
<td align="left">设置任务依赖关系</td>
<td>支持。</td>
<td>不支持。</td>
</tr>
<tr>
<td align="left">串行队列</td>
<td>支持。</td>
<td>不支持。</td>
</tr>
<tr>
<td align="left">任务组</td>
<td>支持。</td>
<td>不支持。</td>
</tr>
</tbody></table>
<h2 id="Worker和TaskPool适用场景对比"><a href="#Worker和TaskPool适用场景对比" class="headerlink" title="Worker和TaskPool适用场景对比"></a>Worker和TaskPool适用场景对比</h2><p>TaskPool和Worker均支持多线程并发能力。由于TaskPool的工作线程会绑定系统的调度优先级，并且支持负载均衡（自动扩缩容），而Worker需要开发者自行创建，存在创建耗时以及不支持设置调度优先级，故在性能方面使用TaskPool会优于Worker，因此大多数场景推荐使用TaskPool。</p>
<p>TaskPool偏向独立任务维度，该任务在线程中执行，无需关注线程的生命周期，超长任务（大于3分钟）会被系统自动回收；而Worker偏向线程的维度，支持长时间占据线程执行，需要主动管理线程生命周期。</p>
<p>常见的一些开发场景及适用具体说明如下：</p>
<ul>
<li><p>运行时间超过3分钟（不包含Promise和async&#x2F;await异步调用的耗时，例如网络下载、文件读写等I&#x2F;O任务的耗时）的任务。例如后台进行1小时的预测算法训练等CPU密集型任务，需要使用Worker。</p>
</li>
<li><p>有关联的一系列同步任务。例如在一些需要创建、使用句柄的场景中，句柄创建每次都是不同的，该句柄需永久保存，保证使用该句柄进行操作，需要使用Worker。</p>
</li>
<li><p>需要设置优先级的任务。例如图库直方图绘制场景，后台计算的直方图数据会用于前台界面的显示，影响用户体验，需要高优先级处理，需要使用TaskPool。</p>
</li>
<li><p>需要频繁取消的任务。例如图库大图浏览场景，为提升体验，会同时缓存当前图片左右侧各2张图片，往一侧滑动跳到下一张图片时，要取消另一侧的一个缓存任务，需要使用TaskPool。</p>
</li>
<li><p>大量或者调度点较分散的任务。例如大型应用的多个模块包含多个耗时任务，不方便使用8个Worker去做负载管理，推荐采用TaskPool。</p>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://qcxhc.github.io/2024/04/25/%E9%B8%BF%E8%92%99/%E5%A4%9A%E7%BA%BF%E7%A8%8B/" data-id="clvezpha30006ykqzhxcf2uav" data-title="多线程能力" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/" rel="tag">多线程</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%B9%B6%E5%8F%91/" rel="tag">并发</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E9%B8%BF%E8%92%99/" rel="tag">鸿蒙</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2024/04/25/%E9%B8%BF%E8%92%99/%E5%B9%B6%E5%8F%91%E4%BB%BB%E5%8A%A1/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">前一篇</strong>
      <div class="article-nav-title">
        
          并发
        
      </div>
    </a>
  
  
    <a href="/2024/04/22/%E9%B8%BF%E8%92%99/%E6%9C%8D%E5%8A%A1%E5%8D%A1%E7%89%87/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">后一篇</strong>
      <div class="article-nav-title">服务卡片</div>
    </a>
  
</nav>

  
</article>


</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/CMake/" rel="tag">CMake</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/TypeScript/" rel="tag">TypeScript</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/hexo/" rel="tag">hexo</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/napi/" rel="tag">napi</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/" rel="tag">多线程</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%B9%B6%E5%8F%91/" rel="tag">并发</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%BC%82%E6%AD%A5%E5%B9%B6%E5%8F%91/" rel="tag">异步并发</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/" rel="tag">性能优化</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%9C%8D%E5%8A%A1%E5%8D%A1%E7%89%87/" rel="tag">服务卡片</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%BB%84%E4%BB%B6/" rel="tag">组件</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%BC%96%E8%AF%91/" rel="tag">编译</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%A3%85%E9%A5%B0%E5%99%A8/" rel="tag">装饰器</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%B8%BF%E8%92%99/" rel="tag">鸿蒙</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签云</h3>
    <div class="widget tagcloud">
      <a href="/tags/CMake/" style="font-size: 10px;">CMake</a> <a href="/tags/TypeScript/" style="font-size: 10px;">TypeScript</a> <a href="/tags/hexo/" style="font-size: 10px;">hexo</a> <a href="/tags/napi/" style="font-size: 10px;">napi</a> <a href="/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/" style="font-size: 10px;">多线程</a> <a href="/tags/%E5%B9%B6%E5%8F%91/" style="font-size: 15px;">并发</a> <a href="/tags/%E5%BC%82%E6%AD%A5%E5%B9%B6%E5%8F%91/" style="font-size: 10px;">异步并发</a> <a href="/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/" style="font-size: 10px;">性能优化</a> <a href="/tags/%E6%9C%8D%E5%8A%A1%E5%8D%A1%E7%89%87/" style="font-size: 10px;">服务卡片</a> <a href="/tags/%E7%BB%84%E4%BB%B6/" style="font-size: 10px;">组件</a> <a href="/tags/%E7%BC%96%E8%AF%91/" style="font-size: 10px;">编译</a> <a href="/tags/%E8%A3%85%E9%A5%B0%E5%99%A8/" style="font-size: 10px;">装饰器</a> <a href="/tags/%E9%B8%BF%E8%92%99/" style="font-size: 20px;">鸿蒙</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/04/">四月 2024</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2024/04/25/%E9%B8%BF%E8%92%99/Node-Api%EF%BC%88NDK%EF%BC%89/">Node-Api（NApi）</a>
          </li>
        
          <li>
            <a href="/2024/04/25/%E9%B8%BF%E8%92%99/%E6%8F%90%E5%8D%87%E5%BA%94%E7%94%A8%E5%86%B7%E5%90%AF%E5%8A%A8%E9%80%9F%E5%BA%A6/">提升应用冷启动速度</a>
          </li>
        
          <li>
            <a href="/2024/04/25/%E9%B8%BF%E8%92%99/%E5%BC%82%E6%AD%A5%E5%B9%B6%E5%8F%91%EF%BC%88Promise%E5%92%8Casync-awit%EF%BC%89/">异步并发（Promise和async/awit）</a>
          </li>
        
          <li>
            <a href="/2024/04/25/%E9%B8%BF%E8%92%99/%E5%B9%B6%E5%8F%91%E4%BB%BB%E5%8A%A1/">并发</a>
          </li>
        
          <li>
            <a href="/2024/04/25/%E9%B8%BF%E8%92%99/%E5%A4%9A%E7%BA%BF%E7%A8%8B/">多线程能力</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2024 青春小火车<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>