[{"title":"差异化构建打包","path":"/2024/04/25/鸿蒙/差异化构建打包/","content":"通常情况下，应用厂商会根据不同的部署环境，不同的目标人群，不同的运行环境等，将同一个应用定制为不同的版本，如国内版、国际版、普通版、VIP版、免费版、付费版等。针对以上场景，DevEco Studio支持通过少量的代码差异化配置处理，在编译构建过程中实现一个应用构建出不同的目标产物版本，从而实现源代码、资源文件等的高效复用。 在了解HarmonyOS应用的多目标构建产物如何定制前，先了解product和target的概念： 一个HarmonyOS工程由一个或多个模块组成，工程的构建产物为APP包，APP包用于应用&#x2F;服务发布上架应用市场。由于不同的业务场景，需要定制不同的应用包，因此引入product概念。一个工程可以定义多个product，每个product对应一个定制化应用包，通过配置可以实现一个工程构建出多个不同的应用包。 工程内的每一个Entry&#x2F;Feature模块，对应的构建产物为HAP，HAP是应用&#x2F;服务可以独立运行在设备中的形态。由于在不同的业务场景中，同一个模块可能需要定制不同的功能或资源，因此引入target的概念。一个模块可以定义多个target，每个target对应一个定制的HAP，通过配置可以实现一个模块构建出不同的HAP。 定制HAP多目标构建产物每一个Entry&#x2F;Feature模块均支持定制不同的target，通过在模块中的build-profile.json5文件中实现差异化定制，当前支持设备类型（deviceType）、源码集（source）、资源（resource）、C++依赖的.so（buildOption）的定制。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&#123; &quot;apiType&quot;: &quot;stageMode&quot;, &quot;buildOption&quot;: &#123;&#125;, &quot;buildOptionSet&quot;: [], &quot;targets&quot;: [ &#123; &quot;name&quot;: &quot;default&quot;, // 对应HAP名称，默认包 &quot;source&quot;: &#123; // 支持的源码集 &quot;pages&quot;: [ // 使用的页面 MainPage &quot;pages/MainPage&quot; ], // FA模型还可以配置使用的Ability // &quot;abilities&quot;: [ // &#123; // &quot;name&quot;: &quot;&quot;, ability名称 // &quot;pages&quot;: [], 使用的页面 // &quot;res&quot;: [] 使用的资源 // &#125; // ] &#125;, &quot;resource&quot;: &#123; &quot;directories&quot;: [ // 使用的资源目录，默认资源 &quot;./src/main/resources&quot; ] &#125;, &quot;config&quot;: &#123; &quot;deviceType&quot;: [ // 支持的设备类型，default表示默认支持Module支持的所有的设备类型 &quot;default&quot; ] &#125; &#125;, &#123; &quot;name&quot;: &quot;tablet&quot;, // 对应HAP名称，平板包 &quot;source&quot;: &#123; &quot;pages&quot;: [ &quot;pages/TabletMainPage&quot; ], &#125;, &quot;resource&quot;: &#123; &quot;directories&quot;: [ // 使用的资源目录，平板资源 &quot;./src/main/tabletResources&quot; ], &#125;, &quot;config&quot;: &#123; &quot;deviceType&quot;: [ // 支持的设备类型，tabblet表示仅支持平板设备 &quot;tablet&quot; ] &#125; &#125; ]&#125; 配置APP多目标构建产物APP用于应用&#x2F;服务上架发布，针对不同的应用场景，可以定制不同的product，每个product中支持对bundleName、签名信息以及包含的target进行定制。 每一个product对应一个定制的APP包，因此，在定制APP多目标构建产物前，应提前规划好需要定制的product名称。 针对每个定义的product，均可以定制不同的bundleName，如果product未定义bundleName，则采用工程默认的bundleName。 可以选择需要将定义的target分别打包到哪一个product中，每个product可以指定一个或多个target，同时每个target也可以打包到不同的product中，但是同一个module的不同target不能打包到同一个product中。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980&#123; &quot;app&quot;: &#123; &quot;signingConfigs&quot;: [ &#123; &quot;name&quot;: &quot;default&quot;, &quot;material&quot;: &#123; ****** &#125; &#125;, &#123; &quot;name&quot;: &quot;tablet&quot;, &quot;material&quot;: &#123; ****** &#125; &#125; ], &quot;multiProjects&quot;: true, // 是否支持多Product &quot;products&quot;: [ &#123; &quot;name&quot;: &quot;default&quot;, // 对应APP名称，默认包 &quot;signingConfig&quot;: &quot;default&quot;, // 对应签名信息 &quot;compileSdkVersion&quot;: 11, &quot;compatibleSdkVersion&quot;: 11, &quot;runtimeOS&quot;: &quot;OpenHarmony&quot;, &#125;, &#123; &quot;name&quot;: &quot;tablet&quot;, &quot;bundleName&quot;: &quot;com.example.ohcase_tablet&quot;, &quot;signingConfig&quot;: &quot;tablet&quot;, &quot;compileSdkVersion&quot;: 11, &quot;compatibleSdkVersion&quot;: 11, &quot;runtimeOS&quot;: &quot;OpenHarmony&quot;, &#125;, ], &#125;, &quot;modules&quot;: [ // 配置模块对product的映射关系 &#123; &quot;name&quot;: &quot;entry&quot;, // entry模块 &quot;srcPath&quot;: &quot;./product/entry&quot;, &quot;targets&quot;: [ &#123; &quot;name&quot;: &quot;default&quot;, // entry模块的default target &quot;applyToProducts&quot;: [ &quot;default&quot;, // default Product使用default target ] &#125;, &#123; &quot;name&quot;: &quot;tablet&quot;, // entry模块的tablet target &quot;applyToProducts&quot;: [ &quot;tablet&quot; // tablet Product使用tablet target ] &#125; ] &#125;, &#123; &quot;name&quot;: &quot;dynamicrouter&quot;, // dynamicrouter模块 &quot;srcPath&quot;: &quot;./feature/dynamicrouter&quot;, &quot;targets&quot;: [ &#123; &quot;name&quot;: &quot;default&quot;, // dynamicrouter模块的default target &quot;applyToProducts&quot;: [ &quot;default&quot; // default Product使用default target ] // 这里tablet Product不使用dynamicrouter模块 &#125; ] &#125;, &#123; &quot;name&quot;: &quot;common&quot;, // common模块 &quot;srcPath&quot;: &quot;./common&quot;, &quot;targets&quot;: [ &#123; &quot;name&quot;: &quot;default&quot;, // common模块的default target &quot;applyToProducts&quot;: [ &quot;default&quot;, &quot;tablet&quot; // default Product和 tablet Product 都使用common模块default target ] &#125; ] &#125; ]&#125; 定义Product的签名配置信息在File &gt; Project Structure &gt; Project &gt; Signing Configs界面配置Product的签名配置信息。 构建定义的目标产物每个target对应一个HAP，每个product对应一个APP包，在编译构建时，如果存在多product或多target时，可以指定编译具体的包。 指定需要打包的Product及Target，然后单击Apply保存。如下图所示： 选择对应的Product，点击构建 -&gt; 构建模块 entry进行构建。此时DevEco Studio将构建生成模块下指定target对应的包。如下图所示： 同时选择对应的Product下，也可以对不同Product下的对应Module Target进行运行或调试。","tags":["鸿蒙","hvigor"]},{"title":"鸿蒙源码简单修改和定制","path":"/2024/04/25/鸿蒙系统编译/鸿蒙源码简单修改和定制/","content":"完成鸿蒙源码编译后，我们就可以做一下简单的修改，定制自己的系统。 开机logo和动画替换开机logo路径: 1device/board/hihope/rk3568/kernel 开机动画路径: 1foundation/graphic/graphic_2d/frameworks/bootanimation/data/bootvideo.mp4 产品信息定制产品信息文件路径： 1/base/startup/init/services/etc/param/ohos.para 123456789101112131415161718192021222324252627const.actionable_compatible_property.enabled=falseconst.postinstall.fstab.prefix=/systemconst.secure=0security.perf_harden=1const.allow.mock.location=0const.debuggable=1const.build.characteristics=defaultconst.product.model=QCXHC // 产品modelconst.product.name=&quot;QCXHC 4.0&quot; // 产品名称const.sandbox=enableconst.product.devicetype=defaultconst.software.model=defaultconst.product.manufacturer=QCXHC // 厂商const.product.brand=QCXHC // 品牌const.build.product=QCXHC4 const.product.hardwareversion=defaultconst.product.bootloader.version=bootloaderconst.product.cpu.abilist=defaultconst.product.software.version=OpenHarmony 4.0.10.18const.product.incremental.version=defaultconst.product.firstapiversion=1const.product.build.type=defaultconst.product.build.user=defaultconst.product.build.host=defaultconst.product.build.date=defaultconst.product.hardwareprofile=defaultconst.ohos.buildroothash=default 修改息屏设置息屏信息文件路径： 1base/powermgr/power_manager/services/native/profile/power_mode_config.xml 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot; ?&gt;&lt;!--Power Mode Definitions: // 电源模式定义MODE_NORMAL = 600, // 正常模式MODE_POWER_SAVE = 601, // 省电模式MODE_PERFORMANCE = 602, // 性能优先MODE_EXTREME_POWER_SAVE = 603, // 超级省电--&gt;&lt;!--Action Definitions: // 行为定义DisplayOffTime = 101, // 息屏时间控制SystemAutoSleepTime = 102, // 系统自动睡眠时间控制AutoAdjustBrightness = 103, // 亮度自动调整时间控制AutoWindowRotation = 107, // 窗口自动旋转时间控制SystemBrightness = 115, // 系统亮度调节VibratorsState = 120, // 马达(震动)状态--&gt;&lt;switch_proxy version=&quot;1&quot;&gt;&lt;proxy id=&quot;600&quot;&gt;&lt;switch id=&quot;101&quot; value=&quot;-1&quot; recover_flag=&quot;0&quot;/&gt;&lt;switch id=&quot;102&quot; value=&quot;-1&quot; recover_flag=&quot;0&quot;/&gt;&lt;switch id=&quot;103&quot; value=&quot;-1&quot; recover_flag=&quot;0&quot;/&gt;&lt;switch id=&quot;107&quot; value=&quot;1&quot; recover_flag=&quot;0&quot;/&gt;&lt;switch id=&quot;115&quot; value=&quot;102&quot; recover_flag=&quot;0&quot;/&gt;&lt;switch id=&quot;120&quot; value=&quot;1&quot; recover_flag=&quot;0&quot;/&gt;&lt;/proxy&gt;&lt;proxy id=&quot;601&quot;&gt;&lt;switch id=&quot;101&quot; value=&quot;-1&quot; recover_flag=&quot;0&quot;/&gt;&lt;switch id=&quot;102&quot; value=&quot;-1&quot; recover_flag=&quot;0&quot;/&gt;&lt;switch id=&quot;103&quot; value=&quot;-1&quot; recover_flag=&quot;0&quot;/&gt;&lt;switch id=&quot;107&quot; value=&quot;-1&quot; recover_flag=&quot;0&quot;/&gt;&lt;switch id=&quot;115&quot; value=&quot;50&quot; recover_flag=&quot;0&quot;/&gt;&lt;switch id=&quot;120&quot; value=&quot;-1&quot; recover_flag=&quot;0&quot;/&gt;&lt;/proxy&gt;&lt;proxy id=&quot;602&quot;&gt;&lt;switch id=&quot;101&quot; value=&quot;-1&quot; recover_flag=&quot;0&quot;/&gt;&lt;switch id=&quot;102&quot; value=&quot;-1&quot; recover_flag=&quot;0&quot;/&gt;&lt;switch id=&quot;103&quot; value=&quot;-1&quot; recover_flag=&quot;0&quot;/&gt;&lt;switch id=&quot;107&quot; value=&quot;1&quot; recover_flag=&quot;0&quot;/&gt;&lt;switch id=&quot;115&quot; value=&quot;255&quot; recover_flag=&quot;0&quot;/&gt;&lt;switch id=&quot;120&quot; value=&quot;1&quot; recover_flag=&quot;0&quot;/&gt;&lt;/proxy&gt;&lt;proxy id=&quot;603&quot;&gt;&lt;switch id=&quot;101&quot; value=&quot;5000&quot; recover_flag=&quot;0&quot;/&gt;&lt;switch id=&quot;102&quot; value=&quot;1000&quot; recover_flag=&quot;0&quot;/&gt;&lt;switch id=&quot;103&quot; value=&quot;-1&quot; recover_flag=&quot;0&quot;/&gt;&lt;switch id=&quot;107&quot; value=&quot;-1&quot; recover_flag=&quot;0&quot;/&gt;&lt;switch id=&quot;115&quot; value=&quot;25&quot; recover_flag=&quot;0&quot;/&gt;&lt;switch id=&quot;120&quot; value=&quot;-1&quot; recover_flag=&quot;0&quot;/&gt;&lt;/proxy&gt;&lt;/switch_proxy&gt; 镜像烧录第一次编译会在4个小时左右，编译后生成的镜像文件在源码目录的 1out/rk3568/packages/phone/images文件夹下 Windows下镜像烧录 从Ubuntu虚拟机下载images文件夹下所有文件到windows中 安装好开发板的USB驱动 连接好烧录线，与串口线 使用RKDevTool工具烧录镜像 开发板现在处于开机状态，双击windows\\RKDevTool.exe 打开烧录工具，按鼠标右键导入配置 选择 config.cfg 配置文件,然后打开 长按 Power 和 VOL+&#x2F;RECOVER 按键超过 6 秒，让开发板关机，抬起手指，这时提示”没有发现设备” 也可使用华为的hdc命令进入loader模式 1hdc target boot loader 再次按下这两个键，这时提示”发现一个 LOADER 设备” 点击设备分区表，更新 点击执行进行烧录, 稍等几分钟后, 这时会在右侧信息框提示“下载完成” 通过串口连接开发板，并运行程序 连接串口 将串口线连接PC与开发板，打开securtCRT串口工具，在设备管理器查看端口，如图： 设置端口和波特率 协议选择Serial，端口和设备管理器保持一致。另外，串口波特率配置为1500000，点击“连接”，如下图所示： 运行镜像 打开串口后，在任意目录（以设备根目录为例）下输入命令helloworld后回车，即出现“Hello World!”字样。 至此，我们修改后的自定制系统就被成功安装到开发板上。"},{"title":"鸿蒙系统编译","path":"/2024/04/25/鸿蒙系统编译/鸿蒙系统编译/","content":"准备工作ubuntu20 虚拟机安装pyenvpyenv可以管理不同的python版本 1.安装pyenv的依赖库执行以下命令安装依赖库 更新源 1sudo apt-get update 更新软件 1234sudo apt-get upgradesudo apt-get install make build-essential libssl-dev zlib1g-devsudo apt-get install libbz2-dev libreadline-dev libsqlite3-dev wget curlsudo apt-get install llvm libncurses5-dev libncursesw5-dev 2.安装pyenv1curl https://pyenv.run | bash 3.配置环境变量将以下三条语句写入 ~&#x2F;.bashrc 1234vim ~/.bashrcexport PATH=&quot;~/.pyenv/bin:$PATH&quot;eval &quot;$(pyenv init -)&quot;eval &quot;$(pyenv virtualenv-init -)&quot; 使配置生效： 1source ~/.bashrc 4.安装库和工具集使用命令行进行设备开发时，可以通过以下步骤安装编译OpenHarmony需要的库和工具。相应操作在Ubuntu环境中进行。 使用如下apt-get命令安装后续操作所需的库和工具：12345678910sudo apt-get install binutils binutils-dev git git-lfs gnupg flex bison gperfbuild-essential zip curl zlib1g-dev libc6-dev-i386 lib32ncurses5-dev x11protocore-dev libx11-dev lib32z1-dev ccache libgl1-mesa-dev libxml2-utils xsltprocunzip m4 bc gnutls-bin python3.8 python3-pip ruby genext2fs device-tree-compilermake libffi-dev e2fsprogs pkg-config perl openssl libssl-dev libelf-dev libdwarfdev u-boot-tools mtd-utils cpio doxygen liblz4-tool openjdk-8-jre gcc g++ texinfodosfstools mtools default-jre default-jdk libncurses5 apt-utils wget sconspython3.8-distutils tar rsync git-core libxml2-dev lib32z-dev grsync xxdlibglib2.0-dev libpixman-1-dev kmod jfsutils reiserfsprogs xfsprogs squashfstools pcmciautils quota ppp libtinfo-dev libtinfo5 libncurses5-dev libncursesw5libstdc++6 gcc-arm-none-eabi vim ssh locales libxinerama-dev libxcursor-devlibxrandr-dev libxi-dev 以上安装命令适用于Ubuntu18.04，其他版本请根据安装包名称采用对应的安装命令 Python要求安装Python3.8以上版本，此处以Python2.8为例。 java要求java8以上版本，此处以java8为例。 若使用的是Ubuntu20及以上版本，由于gcc-multilib和gcc-arm-linux-gnueabi互斥，请勿安转换gcc-arm-linux-gnueabi。 1sudo apt-get install gcc-arm-linux-gnueabi gcc-9-arm-linux-gnueabi 将Python 3.8设置为默认Python版本。 查看Python 3.8的位置： 1which python3.8 将Python和Python3切换为Python 3.8： 123sudo update-alternatives --install /usr/bin/python python &#123;Python 3.8 路径&#125; 1sudo update-alternatives --install /usr/bin/python3 python3 &#123;Python 3.8 路径&#125; 1#&#123;Python 3.8 路径&#125; 为上一步查看的Python 3.8的位置 获取源码在Ubuntu环境下通过以下步骤获取OpenHarmony源码。 发布分支代码相对比较稳定，开发者可基于发布分支代码进行商用功能开发。Master 主干为开发分支，开发者可通过Master主干获取最新特性。 a. OpenHarmony发布分支代码获取 OpenHarmony各个版本发布分支的源码获取方式请参考Release-Notes。 b. OpenHarmony主干代码获取 方式一（推荐）：通过repo + ssh下载（需注册公钥，请参考码云帮助中心）。 1234repo init -u git@gitee.com:openharmony/manifest.git -b OpenHarmony-4.1-Release --no-repo-verifyrepo sync -c -j8repo forall -c &#x27;git lfs pull&#x27; 方式二：通过repo + https下载。 1234repo init -u https://gitee.com/openharmony/manifest.git -b OpenHarmony-4.0-Release --no-repo-verifyrepo sync -crepo forall -c &#x27;git lfs pull&#x27; 编译执行prebuilts在源码根目录下执行prebuilts脚本，安装编译器及二进制工具。 1build/prebuilts_download.sh 编译源码1./build.sh --product-name rk3568 --ccache #./build.sh --product-name rk3568 -- 或者 12target-cpu arm64 --ccache./build.sh --product-name rk3568 --ccache --no-prebuilt-sdk #full-sdk OpenHarmony源码目录结构 目录名 描述 applications 应用程序样例，包括camera等 base 基础软件服务子系统集&amp;硬件服务子系统集 build 组件化编译、构建和配置脚本 gn docs 说明文档 domains 增强软件服务子系统集 drivers 驱动子系统 foundation 系统基础能力子系统集 kernel 内核子系统 prebuilts 编译器及工具链子系统 test 测试子系统 third_party 开源第三方组件 utils 常用的工具集 vendor 厂商提供的软件 build.py 编译脚本文件","tags":["编译","鸿蒙"]},{"title":"Node-Api（NApi）","path":"/2024/04/25/鸿蒙/Node-Api（NDK）/","content":"在HarmonyOS中，C API中的N-API接口可以实现ArkTS&#x2F;TS&#x2F;JS与C&#x2F;C++之间的交互。N-API提供的接口名与三方Node.js一致，目前支持部分接口。 NDKNDK（Native Development Kit）是OpenHarmony SDK提供的Native API、相应编译脚本和编译工具链的集合，方便开发者使用C或C++语言实现应用的关键功能。NDK只覆盖了OpenHarmony一些基础的底层能力，如C运行时基础库libc、图形库、窗口系统、多媒体、压缩库、面向ArkTS&#x2F;JS与C跨语言的Node-API等，并没有提供ArkTS&#x2F;JS API的完整能力。 运行态，开发者可以使用NDK中的Node-API接口，访问、创建、操作JS对象；也允许JS对象使用Native动态库。 开发流程在DevEco Studio的模板工程中包含使用N-API的默认工程，使用File-&gt;New-&gt;Create Project创建Native C++模板工程。创建后在entry&#x2F;src&#x2F;main目录下会包含cpp目录，可以使用N-API接口，开发C&#x2F;C++代码（native侧代码）。 ArkTS&#x2F;TS&#x2F;JS侧通过import引入native侧的so文件，如：import hello from ‘libhello.so’，意为使用libhello.so的能力，并将名为hello的ArkTS&#x2F;TS&#x2F;JS对象给到应用的ArkTS&#x2F;TS&#x2F;JS侧，开发者可通过该对象，调用到在cpp中开发的native方法。 示例代码C++侧代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384// entry\\src\\main\\cpp\\hello.cpp// 引入N-API相关头文件。#include &quot;napi/native_api.h&quot;// 开发者提供的native方法，入参有且仅有如下两个，开发者不需进行变更。// napi_env 为当前运行的上下文。// napi_callback_info 记录了一些信息，包括从ArkTS侧传递过来参数等。static napi_value Add(napi_env env, napi_callback_info info)&#123; // 期望从ArkTS侧获取的参数的数量，napi_value可理解为ArkTS value在native方法中的表现形式。 size_t argc = 2; napi_value args[2] = &#123;nullptr&#125;; // 从info中，拿到从ArkTS侧传递过来的参数，此处获取了两个ArkTS参数，即arg[0]和arg[1]。 napi_get_cb_info(env, info, &amp;argc, args , nullptr, nullptr); // 将获取的ArkTS参数转换为native信息，此处ArkTS侧传入了两个number，这里将其转换为native侧可以操作的double类型。 double value0; napi_get_value_double(env, args[0], &amp;value0); double value1; napi_get_value_double(env, args[1], &amp;value1); // native侧的业务逻辑，这里简单以两数相加为例。 double nativeSum = value0 + value1; // 此处将native侧业务逻辑处理结果转换为ArkTS值，并返回给ArkTS。 napi_value sum; napi_create_double(env, nativeSum , &amp;sum); return sum;&#125;static napi_value NativeCallArkTS(napi_env env, napi_callback_info info)&#123; // 期望从ArkTS侧获取的参数的数量，napi_value可理解为ArkTS value在native方法中的表现形式。 size_t argc = 1; napi_value args[1] = &#123;nullptr&#125;; // 从info中，拿到从ArkTS侧传递过来的参数，此处获取了一个ArkTS参数，即arg[0]。 napi_get_cb_info(env, info, &amp;argc, args , nullptr, nullptr); // 创建一个ArkTS number作为ArkTS function的入参。 napi_value argv = nullptr; napi_create_int32(env, 10, &amp;argv); napi_value result = nullptr; // native方法中调用ArkTS function，其返回值保存到result中并返到ArkTS侧。 napi_call_function(env, nullptr, args[0], 1, &amp;argv, &amp;result); return result;&#125;EXTERN_C_START// Init将在exports上挂上Add/NativeCallArkTS这些native方法，此处的exports就是开发者import之后获取到的ArkTS对象。static napi_value Init(napi_env env, napi_value exports)&#123; // 函数描述结构体，以Add为例，第三个参数&quot;Add&quot;为上述的native方法， // 第一个参数&quot;add&quot;为ArkTS侧对应方法的名称。 napi_property_descriptor desc[] = &#123; &#123; &quot;add&quot;, nullptr, Add, nullptr, nullptr, nullptr, napi_default, nullptr &#125;, &#123; &quot;nativeCallArkTS&quot;, nullptr, NativeCallArkTS, nullptr, nullptr, nullptr, napi_default, nullptr &#125;, &#125;; // 在exports这个ArkTS对象上，挂载native方法。 napi_define_properties(env, exports, sizeof(desc) / sizeof(desc[0]), desc); return exports;&#125;EXTERN_C_END// 准备模块加载相关信息，将上述Init函数与本模块名等信息记录下来。static napi_module demoModule = &#123; .nm_version =1, .nm_flags = 0, .nm_filename = nullptr, .nm_register_func = Init, .nm_modname = &quot;entry&quot;, .nm_priv = ((void*)0), .reserved = &#123; 0 &#125;,&#125;;// 打开so时，该函数将自动被调用，使用上述demoModule模块信息，进行模块注册相关动作。extern &quot;C&quot; __attribute__((constructor)) void RegisterHelloModule(void)&#123; napi_module_register(&amp;demoModule);&#125; CMakeLists.txt文件中配置CMake打包参数：1234567891011121314151617181920212223242526# entry/src/main/cpp/CMakeLists.txt# 确定CMake的最小版本号。cmake_minimum_required(VERSION 3.4.1)# 定义项目名称project(MyApplication2)# 设置项目根目录。set(NATIVERENDER_ROOT_PATH $&#123;CMAKE_CURRENT_SOURCE_DIR&#125;)# 设置头文件搜索路径。include_directories($&#123;NATIVERENDER_ROOT_PATH&#125; $&#123;NATIVERENDER_ROOT_PATH&#125;/include)# 添加名为entry的库# entry 库名称# SHARED 库类型（SHARE：动态库，STATIC：静态库）# hello.cpp 库包含的源文件add_library(entry SHARED hello.cpp)# 构建此可执行文件需要链接的库# target 需要连接的库文件的目标文件# PUBLIC 链接库类型，默认PUBLIC# libace_napi.z.so 需要链接库的名称target_link_libraries(entry PUBLIC libace_napi.z.so) C++暴露给ArkTS测接口声明：1234// entry\\src\\main\\cpp\\types\\libentry\\index.d.ts// native侧暴露给ArkTS侧接口的声明。export const add: (a: number, b: number) =&gt; number;export const nativeCallArkTS: (a: object) =&gt; number; ArkTS侧代码：123456789101112131415161718192021222324252627282930313233343536// entry\\src\\main\\ets\\pages\\index.etsimport hilog from &#x27;@ohos.hilog&#x27;;// 通过import的方式，引入native能力。import entry from &#x27;libentry.so&#x27;@Entry@Componentstruct Index &#123; build() &#123; Row() &#123; Column() &#123; // 第一个按钮，调用add方法，对应到native侧的Add方法，进行两数相加。 Button(&#x27;ArkTS call C++&#x27;) .fontSize(50) .fontWeight(FontWeight.Bold) .onClick(() =&gt; &#123; hilog.isLoggable(0x0000, &#x27;testTag&#x27;, hilog.LogLevel.INFO); hilog.info(0x0000, &#x27;testTag&#x27;, &#x27;Test NAPI 2 + 3 = %&#123;public&#125;d&#x27;, entry.add(2, 3)); &#125;) // 第二个按钮，调用nativeCallArkTS方法，对应到native的NativeCallArkTS，在native中执行ArkTS function。 Button(&#x27;C++ call ArkTS&#x27;) .fontSize(50) .fontWeight(FontWeight.Bold) .onClick(() =&gt; &#123; hilog.isLoggable(0x0000, &#x27;testTag&#x27;, hilog.LogLevel.INFO); let ret = entry.nativeCallArkTS((value)=&gt;&#123;return value * 2;&#125;); hilog.info(0x0000, &#x27;testTag&#x27;, &#x27;Test NAPI nativeCallArkTS ret = %&#123;public&#125;d&#x27;, ret); &#125;) &#125; .width(&#x27;100%&#x27;) &#125; .height(&#x27;100%&#x27;) &#125;&#125;","tags":["鸿蒙","napi"]},{"title":"提升应用冷启动速度","path":"/2024/04/25/鸿蒙/提升应用冷启动速度/","content":"应用冷启动的过程应用冷启动过程大致可分成以下四个阶段：应用进程创建&amp;初始化、Application&amp;Ability初始化、Ability&#x2F;AbilityStage生命周期、加载绘制首页，如下图： 1、缩短应用进程创建&amp;初始化阶段耗时该阶段主要是系统完成应用进程的创建以及初始化的过程，包含了启动页图标(startWindowIcon)的解码。 设置合适分辨率的startWindowIcon如果启动页图标分辨率过大，解码耗时会影响应用的启动速度，建议启动页图标分辨率不超过256像素*256像素。 2、缩短Application&amp;Ability初始化阶段耗时该阶段主要是资源加载、虚拟机创建、Application&amp;Ability相关对象的创建与初始化、依赖模块的加载等。 减少import的模块应用代码执行前，应用程序必须找到并加载import的所有模块，应用程序加载的每个额外的第三方框架或者模块都会增加启动时间，耗时长短取决于加载的第三方框架或者模块的数量和大小。推荐开发者尽可能使用系统提供的模块，按需加载，来缩短应用程序的启动耗时。 3、缩短AbilityStage生命周期阶段耗时该阶段主要是AbilityStage的启动生命周期，执行相应的生命周期回调。 避免在AbilityStage生命周期回调接口进行耗时操作在应用启动流程中，系统会执行AbilityStage的生命周期回调函数。因此，不建议在这些回调函数中执行耗时过长的操作，耗时操作建议通过异步任务延迟处理或者放到其他线程执行 4、缩短Ability生命周期阶段耗时该阶段主要是Ability的启动生命周期，执行相应的生命周期回调。 避免在Ability生命周期回调接口进行耗时操作在应用启动流程中，系统会执行Ability的生命周期回调函数。因此，不建议在这些回调函数中执行耗时过长的操作，耗时操作建议通过异步任务延迟处理或者放到其他线程执行。 5、缩短加载绘制首页阶段耗时该阶段主要是加载首页内容、测量布局、刷新组件并绘制。 自定义组件生命周期回调接口里避免耗时操作自定义组件的生命周期变更会调用相应的回调函数。 aboutToAppear函数会在创建自定义组件实例后，页面绘制之前执行，以下代码在aboutToAppear中对耗时间的计算任务进行了异步处理，避免在该接口执行该耗时操作，不阻塞页面绘制。","tags":["鸿蒙","性能优化"]},{"title":"异步并发（Promise和async/awit）","path":"/2024/04/25/鸿蒙/异步并发（Promise和async-awit）/","content":"简介Promise和async&#x2F;await提供异步并发能力，是标准的JS异步语法。异步代码会被挂起并在之后继续执行，同一时间只有一段代码执行，适用于单次I&#x2F;O任务的场景开发，例如一次网络请求、一次文件读写等操作。 异步语法是一种编程语言的特性，允许程序在执行某些操作时不必等待其完成，而是可以继续执行其他操作。 PromisePromise是一种用于处理异步操作的对象，可以将异步操作转换为类似于同步操作的风格，以方便代码编写和维护。Promise提供了一个状态机制来管理异步操作的不同阶段，并提供了一些方法来注册回调函数以处理异步操作的成功或失败的结果。 Promise有三种状态：pending（进行中）、fulfilled（已完成）和rejected（已拒绝）。Promise对象创建后处于pending状态，并在异步操作完成后转换为fulfilled或rejected状态。 最基本的用法是通过构造函数实例化一个Promise对象，同时传入一个带有两个参数的函数，通常称为executor函数。executor函数接收两个参数：resolve和reject，分别表示异步操作成功和失败时的回调函数。例如，以下代码创建了一个Promise对象并模拟了一个异步操作： 123456789101112131415161718192021const promise: Promise&lt;number&gt; = new Promise((resolve: Function, reject: Function) =&gt; &#123;setTimeout(() =&gt; &#123; const randomNumber: number = Math.random(); if (randomNumber &gt; 0.5) &#123; resolve(randomNumber); &#125; else &#123; reject(new Error(&#x27;Random number is too small&#x27;)); &#125;&#125;, 1000);&#125;)tsconst promise: Promise&lt;number&gt; = new Promise((resolve: Function, reject: Function) =&gt; &#123;setTimeout(() =&gt; &#123; const randomNumber: number = Math.random(); if (randomNumber &gt; 0.5) &#123; resolve(randomNumber); &#125; else &#123; reject(new Error(&#x27;Random number is too small&#x27;)); &#125;&#125;, 1000);&#125;) 上述代码中，setTimeout函数模拟了一个异步操作，并在1秒钟后随机生成一个数字。如果随机数大于0.5，则执行resolve回调函数并将随机数作为参数传递；否则执行reject回调函数并传递一个错误对象作为参数。 Promise对象创建后，可以使用then方法和catch方法指定fulfilled状态和rejected状态的回调函数。then方法可接受两个参数，一个处理fulfilled状态的函数，另一个处理rejected状态的函数。只传一个参数则表示当Promise对象状态变为fulfilled时，then方法会自动调用这个回调函数，并将Promise对象的结果作为参数传递给它。使用catch方法注册一个回调函数，用于处理“失败”的结果，即捕获Promise的状态改变为rejected状态或操作失败抛出的异常。例如： 123456789101112131415import &#123; BusinessError &#125; from &#x27;@ohos.base&#x27;;promise.then((result: number) =&gt; &#123; console.info(`Random number is $&#123;result&#125;`);&#125;).catch((error: BusinessError) =&gt; &#123; console.error(error.message);&#125;);tsimport &#123; BusinessError &#125; from &#x27;@ohos.base&#x27;;promise.then((result: number) =&gt; &#123; console.info(`Random number is $&#123;result&#125;`);&#125;).catch((error: BusinessError) =&gt; &#123; console.error(error.message);&#125;); 上述代码中，then方法的回调函数接收Promise对象的成功结果作为参数，并将其输出到控制台上。如果Promise对象进入rejected状态，则catch方法的回调函数接收错误对象作为参数，并将其输出到控制台上。 async&#x2F;awaitasync&#x2F;await是一种用于处理异步操作的Promise语法糖，使得编写异步代码变得更加简单和易读。通过使用async关键字声明一个函数为异步函数，并使用await关键字等待Promise的解析（完成或拒绝），以同步的方式编写异步操作的代码。 async函数是一个返回Promise对象的函数，用于表示一个异步操作。在async函数内部，可以使用await关键字等待一个Promise对象的解析，并返回其解析值。如果一个async函数抛出异常，那么该函数返回的Promise对象将被拒绝，并且异常信息会被传递给Promise对象的onRejected()方法。 下面是一个使用async&#x2F;await的例子，其中模拟了一个异步操作，该操作会在3秒钟后返回一个字符串。 123456789101112131415161718192021async function myAsyncFunction(): Promise&lt;void&gt; &#123; const result: string = await new Promise((resolve: Function) =&gt; &#123; setTimeout(() =&gt; &#123; resolve(&#x27;Hello, world!&#x27;); &#125;, 3000); &#125;); console.info(result); // 输出： Hello, world!&#125;myAsyncFunction();tsasync function myAsyncFunction(): Promise&lt;void&gt; &#123; const result: string = await new Promise((resolve: Function) =&gt; &#123; setTimeout(() =&gt; &#123; resolve(&#x27;Hello, world!&#x27;); &#125;, 3000); &#125;); console.info(result); // 输出： Hello, world!&#125;myAsyncFunction(); 在上述示例代码中，使用了await关键字来等待Promise对象的解析，并将其解析值存储在result变量中。 需要注意的是，由于要等待异步操作完成，因此需要将整个操作包在async函数中。除了在async函数中使用await外，还可以使用try&#x2F;catch块来捕获异步操作中的异常。 1234567891011async function myAsyncFunction(): Promise&lt;void&gt; &#123; try &#123; const result: string = await new Promise((resolve: Function) =&gt; &#123; resolve(&#x27;Hello, world!&#x27;); &#125;); &#125; catch (e) &#123; console.error(`Get exception: $&#123;e&#125;`); &#125;&#125;myAsyncFunction();","tags":["鸿蒙","并发","异步并发"]},{"title":"并发","path":"/2024/04/25/鸿蒙/并发任务/","content":"并发概述并发是指在同一时间段内，能够处理多个任务的能力。为了提升应用的响应速度与帧率，以及防止耗时任务对主线程的干扰，OpenHarmony系统提供了异步并发和多线程并发两种处理策略。 异步并发是指异步代码在执行到一定程度后会被暂停，以便在未来某个时间点继续执行，这种情况下，同一时间只有一段代码在执行。 多线程并发允许在同一时间段内同时执行多段代码。在主线程继续响应用户操作和更新UI的同时，后台也能执行耗时操作，从而避免应用出现卡顿。 并发能力在多种场景中都有应用，其中包括单次I&#x2F;O任务、CPU密集型任务、I&#x2F;O密集型任务和同步任务等。开发者可以根据不同的场景，选择相应的并发策略进行优化和开发。 ArkTS支持异步并发和多线程并发。 Promise和async&#x2F;await提供异步并发能力，适用于单次I&#x2F;O任务的开发场景。详细请参见异步并发概述。 TaskPool和Worker提供多线程并发能力，适用于CPU密集型任务、I&#x2F;O密集型任务和同步任务等并发场景。详细请参见多线程并发概述。","tags":["鸿蒙","并发"]},{"title":"多线程能力","path":"/2024/04/25/鸿蒙/多线程/","content":"简介应用中的每个进程都会有一个主线程，主线程主要承担执行UI绘制操作、管理ArkTS引擎实例的创建和销毁、分发和处理事件、管理Ability生命周期等职责，具体可参见线程模型概述。因此，开发应用时应当尽量避免将耗时的操作放在主线程中执行。ArkTS提供了Worker和TaskPool两种多线程并发能力。 鸿蒙系统中Worker和TaskPool都是基于Actor并发模型实现的并发能力。 Actor需要明确指定消息接收方，而CSP中处理单元不用关心这些，只需要把消息发送给Channel，而接收方只需要从Channel读取消息。 由于在默认情况下Channel是没有缓存的，因此对Channel的发送（Send）动作是同步阻塞的，直到另外一个持有该Channel引用的执行块取出消息，而Actor模型中信箱本质是队列，因此消息的发送和接收可以是异步的。 WorkerWorker是一个独立的线程。Worker拥有独立的运行环境，每个Worker线程和主线程一样拥有自己的内存空间、消息队列（MessageQueue）、事件轮询机制（EventLoop）、调用栈（CallStack）等。线程之间通过消息（Massage）进行交互。 使用场景 运行时间超过3分钟的任务，需要使用Worker。 有关联的一系列同步任务，例如数据库增、删、改、查等，要保证同一个句柄，需要使用Worker。 使用方法1、宿主线程创建一个Worker线程。通过new worker.ThreadWorker()创建Worker实例，示例代码如下： 1234567// 引入worker模块import worker, &#123; MessageEvents &#125; from &#x27;@ohos.worker&#x27;;import type common from &#x27;@ohos.app.ability.common&#x27;; let workerInstance: worker.ThreadWorker = new worker.ThreadWorker(&#x27;entry/ets/pages/workers/worker.ts&#x27;, &#123; name: &#x27;FriendsMoments Worker&#x27;&#125;); 2、宿主线程给Worker线程发送任务消息。宿主线程通过postMessage方法来发送消息给Worker线程，启动下载解压任务，示例代码如下 1234// 请求网络数据let context: common.UIAbilityContext = getContext(this) as common.UIAbilityContext;// 参数中mediaData和isImageData是根据开发者自己的业务需求添加的，其中mediaData为数据路径、isImageData为判断图片或视频的标识workerInstance.postMessage(&#123; context, mediaData: this.mediaData, isImageData: this.isImageData &#125;); 3、Worker线程监听宿主线程发送的消息。Worker线程在onmessage中接收到宿主线程的postMessage请求，执行下载解压任务，示例代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546// 引入worker模块import worker, &#123; MessageEvents &#125; from &#x27;@ohos.worker&#x27;; let workerPort = worker.workerPort;// 接收宿主线程的postMessage请求workerPort.onmessage = (e: MessageEvents): void =&gt; &#123; // 下载视频文件 let context: common.UIAbilityContext = e.data.context; let filesDir: string = context.filesDir; let time: number = new Date().getTime(); let inFilePath: string = `$&#123;filesDir&#125;/$&#123;time.toString()&#125;.zip`; let mediaDataUrl: string = e.data.mediaData; let urlPart: string = mediaDataUrl.split(&#x27;.&#x27;)[1]; let length: number = urlPart.split(&#x27;/&#x27;).length; let fileName: string = urlPart.split(&#x27;/&#x27;)[length-1]; let options: zlib.Options = &#123; level: zlib.CompressLevel.COMPRESS_LEVEL_DEFAULT_COMPRESSION &#125;; request.downloadFile(context, &#123; url: mediaDataUrl, filePath: inFilePath &#125;).then((downloadTask) =&gt; &#123; downloadTask.on(&#x27;progress&#x27;, (receivedSize: number, totalSize: number) =&gt; &#123; Logger.info(`receivedSize:$&#123;receivedSize&#125;,totalSize:$&#123;totalSize&#125;`); &#125;); downloadTask.on(&#x27;complete&#x27;, () =&gt; &#123; // 下载完成之后执行解压操作 zlib.decompressFile(inFilePath, filesDir, options, (errData: BusinessError) =&gt; &#123; if (errData !== null) &#123; ... // 异常处理 &#125; let videoPath: string = `$&#123;filesDir&#125;/$&#123;fileName&#125;/$&#123;fileName&#125;.mp4`; workerPort.postMessage(&#123; &#x27;isComplete&#x27;: true, &#x27;filePath&#x27;: videoPath &#125;); &#125;) &#125;); downloadTask.on(&#x27;fail&#x27;, () =&gt; &#123; ... // 异常处理 &#125;); &#125;).catch((err) =&gt; &#123; ... // 异常处理 &#125;);&#125;; 4、宿主线程监听Worker线程发送的信息。宿主线程通过onmessage接收到Worker线程发送的消息，并执行下载的结果通知。 5、释放Worker资源。在业务完成或者页面销毁时，调用workerPort.close()接口主动释放Worker资源，示例代码如下所示： 12345678910workerInstance.onmessage = (e: MessageEvents): void =&gt; &#123; if (e.data) &#123; this.downComplete = e.data[&#x27;isComplete&#x27;]; this.filePath = e.data[&#x27;filePath&#x27;]; workerInstance.terminate(); setTimeout(() =&gt; &#123; this.downloadStatus = false; &#125;, LOADING_DURATION_OPEN); &#125;&#125;; TaskPool相比使用Worker实现多线程并发，TaskPool更加易于使用，创建开销也少于Worker，并且Worker线程有个数限制，需要开发者自己掌握。TaskPool作用是为应用程序提供一个多线程的运行环境。TaskPool在Worker之上实现了调度器和Worker线程池，TaskPool根据任务的优先级，将其放入不同的优先级队列，调度器会依据自己实现的调度算法（优先级，防饥饿），从优先级队列中取出任务，放入TaskPool中的Worker线程池，执行相关任务。 TaskPool特点 轻量化的并行机制。 降低整体资源的消耗。 提高系统的整体性能。 无需关心线程实例的生命周期。 可以使用TaskPool API创建后台任务（Task），并对所创建的任务进行如任务执行、任务取消的操作。 根据任务负载动态调节TaskPool工作线程的数量，以使任务按照预期时间完成任务。 可以设置任务的优先级。 可以设置任务组（TaskGroup）将任务关联起来。 使用场景 需要设置优先级的任务。 需要频繁取消的任务。 大量或者调度点较分散的任务。 使用方法1、首先import引入TaskPool模块。 123import taskpool from &#x27;@ohos.taskpool&#x27;;typescriptimport taskpool from &#x27;@ohos.taskpool&#x27;; 2、new一个task对象，其中传入被调用的方法和参数。 12345678910111213141516171819202122232425262728293031// 创建task任务项，参数1.任务执行需要传入函数 参数2.任务执行传入函数的参数 （本示例中此参数为被调用的网络地址字符串）let task: taskpool.Task = new taskpool.Task(getWebData, jsonUrl);// 获取网络数据@Concurrentasync function getWebData(url: string): Promise&lt;Array&lt;FriendMoment&gt;&gt; &#123; try &#123; let webData: http.HttpResponse = await http.createHttp().request( url, &#123; header: &#123; &#x27;Content-Type&#x27;: &#x27;application/json&#x27; &#125;, connectTimeout: 60000, readTimeout: 60000 &#125;) if (typeof (webData.result) === &#x27;string&#x27;) &#123; // 解析json字符串 let jsonObj: Array&lt;FriendMoment&gt; = await JSON.parse(webData.result).FriendMoment; let friendMomentBuckets: Array&lt;FriendMoment&gt; = new Array&lt;FriendMoment&gt;(); // 下方源码省略，主要为数据解析和耗时操作处理 ... return friendMomentBuckets; &#125; else &#123; // 异常处理 ... &#125; &#125; catch (err) &#123; // 异常处理 ... &#125;&#125; 3、之后使用taskpool.execute执行TaskPool任务，将待执行的函数放入TaskPool内部任务队列等待执行。execute需要两个参数：创建的任务对象、等待执行的任务组的优先级，默认值是Priority.MEDIUM。在TaskPool中执行完数据下载、解析和处理后，再返回给主线程中。 123let friendMomentArray: Array&lt;FriendMoment&gt; = await taskpool.execute(task, taskpool.Priority.MEDIUM) as Array&lt;FriendMoment&gt;;typescriptlet friendMomentArray: Array&lt;FriendMoment&gt; = await taskpool.execute(task, taskpool.Priority.MEDIUM) as Array&lt;FriendMoment&gt;; 4、将新获取的momentData通过AppStorage.setOrCreate传入页面组件中。 12345678// 获取页面组件中的momentData对象，其中是组件所需的username、image、video等数据let momentData = AppStorage.get&lt;FriendMomentsData&gt;(&#x27;momentData&#x27;);// 循环遍历对象并依次传入momentDatafor (let i = 0; i &lt; friendMomentArray.length; i++) &#123; momentData.pushData(friendMomentArray[i]);&#125;// 将更新的momentData返回给页面组件AppStorage.setOrCreate(&#x27;momentData&#x27;, momentData); Worker和TaskPool实现特点对比 实现 TaskPool Worker 线程隔离 是 是 内存模型 线程间隔离，内存不共享。 线程间隔离，内存不共享。 参数传递机制 采用标准的结构化克隆算法（Structured Clone）进行序列化、反序列化，完成参数传递。 支持ArrayBuffer转移和SharedArrayBuffer共享。 采用标准的结构化克隆算法（Structured Clone）进行序列化、反序列化，完成参数传递。 支持ArrayBuffer转移和SharedArrayBuffer共享。 参数传递 直接传递，无需封装，默认进行transfer。 消息对象唯一参数，需要自己封装。 方法调用 直接将方法传入调用。 在Worker线程中进行消息解析并调用对应方法。 返回值 异步调用后默认返回。 主动发送消息，需在onmessage解析赋值。 生命周期 TaskPool自行管理生命周期，无需关心任务负载高低。 开发者自行管理Worker的数量及生命周期。 任务池个数上限 自动管理，无需配置。 同个进程下，最多支持同时开启8个Worker线程。 任务执行时长上限 3分钟（不包含Promise和async&#x2F;await异步调用的耗时，例如网络下载、文件读写等I&#x2F;O任务的耗时）。 无限制。 设置任务的优先级 支持配置任务优先级。 不支持。 执行任务的取消 支持取消已经发起的任务。 不支持。 线程复用 支持。 不支持。 任务延时执行 支持。 不支持。 设置任务依赖关系 支持。 不支持。 串行队列 支持。 不支持。 任务组 支持。 不支持。 Worker和TaskPool适用场景对比TaskPool和Worker均支持多线程并发能力。由于TaskPool的工作线程会绑定系统的调度优先级，并且支持负载均衡（自动扩缩容），而Worker需要开发者自行创建，存在创建耗时以及不支持设置调度优先级，故在性能方面使用TaskPool会优于Worker，因此大多数场景推荐使用TaskPool。 TaskPool偏向独立任务维度，该任务在线程中执行，无需关注线程的生命周期，超长任务（大于3分钟）会被系统自动回收；而Worker偏向线程的维度，支持长时间占据线程执行，需要主动管理线程生命周期。 常见的一些开发场景及适用具体说明如下： 运行时间超过3分钟（不包含Promise和async&#x2F;await异步调用的耗时，例如网络下载、文件读写等I&#x2F;O任务的耗时）的任务。例如后台进行1小时的预测算法训练等CPU密集型任务，需要使用Worker。 有关联的一系列同步任务。例如在一些需要创建、使用句柄的场景中，句柄创建每次都是不同的，该句柄需永久保存，保证使用该句柄进行操作，需要使用Worker。 需要设置优先级的任务。例如图库直方图绘制场景，后台计算的直方图数据会用于前台界面的显示，影响用户体验，需要高优先级处理，需要使用TaskPool。 需要频繁取消的任务。例如图库大图浏览场景，为提升体验，会同时缓存当前图片左右侧各2张图片，往一侧滑动跳到下一张图片时，要取消另一侧的一个缓存任务，需要使用TaskPool。 大量或者调度点较分散的任务。例如大型应用的多个模块包含多个耗时任务，不方便使用8个Worker去做负载管理，推荐采用TaskPool。","tags":["鸿蒙","并发","多线程"]},{"title":"服务卡片","path":"/2024/04/22/鸿蒙/服务卡片/","content":"服务卡片是一种界面展示形式，可以将应用的重要信息或操作前置到卡片，以达到服务直达、减少体验层级的目的。卡片常用于嵌入到其他应用（当前卡片使用方只支持系统应用，如桌面）中作为其界面显示的一部分，并支持拉起页面、发送消息等基础的交互功能。 卡片的约束由于ArkTS卡片显示在使用方应用中，使用方应用一般为桌面应用，为确保桌面的使用体验以及功耗相关考虑，对ArkTS卡片的能力做了以下约束： 不支持加载so。 不支持使用native语言开发。 仅支持声明式范式的部分组件、事件、动效、数据管理、状态管理和API能力。 卡片的事件处理和使用方的事件处理是独立的，建议在使用方支持左右滑动的场景下卡片内容不要使用左右滑动功能的组件，以防手势冲突影响交互体验。 除此之外，当前ArkTS卡片还存在如下约束： 暂不支持导入模块。 暂不支持极速预览。 暂不支持断点调试能力。 暂不支持Hot Reload热重载。 卡片生命周期管理onAddForm(want)卡片提供方接收创建卡片的通知接口。 onCastToNormalForm(formId)临时卡片转常态卡片的通知接口。 onUpdateForm(formId)卡片提供方接收更新卡片的通知接口。获取最新数据后调用formProvider的updateForm接口刷新卡片数据。 onChangeFormVisibility(newStatus)卡片提供方接收修改可见性的通知接口。 onFormEvent(formId, message)卡片提供方接收处理卡片事件的通知接口。,卡片页面调用message事件会触发该回调 onRemoveForm(formId)卡片提供方接收销毁卡片的通知接口。 onConfigurationUpdate(newConfig)当系统配置更新时调用。 onAcquireFormState(want)卡片提供方接收查询卡片状态通知接口。默认返回卡片初始状态。 刷新卡片ArkTS卡片框架提供了updateForm()接口和requestForm()接口主动触发卡片的页面刷新。 updateForm 由卡片提供方调用，仅允许刷新自己的卡片 requestForm 卡片使用方调用，目前卡片使用方仅为系统应用 123456789101112 let formData = &#123; &#x27;title&#x27;: &#x27;Title Update Success.&#x27;, // 和卡片布局中对应 &#x27;detail&#x27;: &#x27;Detail Update Success.&#x27;, // 和卡片布局中对应&#125;;// 卡片页面对应绑定title和detail字段会触发UI刷新let formInfo = formBindingData.createFormBindingData(formData)formProvider.updateForm(formId, formInfo).then((data) =&gt; &#123; console.info(&#x27;FormAbility updateForm success.&#x27; + JSON.stringify(data));&#125;).catch((error) =&gt; &#123; console.error(&#x27;FormAbility updateForm failed: &#x27; + JSON.stringify(error));&#125;) 卡片使事件能力ArkTS卡片中提供了postCardAction(component: Object, action: Object)接口用于卡片内部和提供方应用间的交互，当前支持router、message和call三种类型的事件，仅在卡片中可以调用。 component: 当前自定义组件的实例，通常传入this。action: 事件对象，包含action类型、跳转方信息、参数等字段。 router事件跳转到提供方应用的指定UIAbility。 123456789101112131415161718192021// 卡片中调用router事件，拉起对应的UIAbilitypostCardAction(this, &#123; &#x27;action&#x27;: &#x27;router&#x27;, &#x27;bundleName&#x27;: &#x27;com.example.myapplication&#x27;, &#x27;abilityName&#x27;: &#x27;EntryAbility&#x27;, &#x27;params&#x27;: &#123; &#x27;detail&#x27;: &#x27;RouterFromCard&#x27; // 自定义要发送的数据 &#125;&#125;);// 对应被拉起的UIAbility中获取卡片传递的数据// 如果UIAbility已经在后台运行，则会触发onNewWant生命周期回调 onCreate(want, launchParam) &#123; if (want.parameters[formInfo.FormParam.IDENTITY_KEY] !== undefined) &#123; let curFormId = want.parameters[formInfo.FormParam.IDENTITY_KEY]; let msg = JSON.parse(want.parameters.params).detail; // 对应的自定义数据 &#x27;RouterFromCard&#x27; // 可以进行相应的业务处理或者卡片刷新 // todo &#125; &#125; call事件后台启动提供方应用。触发后会拉起提供方应用的指定UIAbility（仅支持launchType为singleton的UIAbility，即启动模式为单实例的UIAbility），但不会调度到前台。提供方应用需要具备后台运行权限 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748// FormAbility.etsonAddForm(want) &#123; let formId = want.parameters[&quot;ohos.extra.param.key.form_identity&quot;]; let formData = formBindingData.createFormBindingData(&#123; &quot;formId&quot;: formId &#125;); // 将卡片id绑定到卡片数据中 return formData; &#125;// widgetCard.ets// 获取卡片数据中的卡片id字段@LocalStorageProp(&#x27;formId&#x27;) formId: string = &#x27;0&#x27;;// 卡片中调用call事件，拉起对应的UIAbilitypostCardAction(this, &#123; &#x27;action&#x27;: &#x27;call&#x27;, &#x27;bundleName&#x27;: &#x27;com.example.myapplication&#x27;, &#x27;abilityName&#x27;: &#x27;EntryAbility&#x27;, &#x27;params&#x27;: &#123; &#x27;mehtod&#x27;: &#x27;callFromCard&#x27;, &#x27;formId&#x27;: this.formId, &#x27;detail&#x27;: &#x27;CallFromCard&#x27; // 自定义要发送的数据 &#125;&#125;);// UIAbility中获监听call事件，获取卡片传递的数据onCreate(want, launchParam) &#123; console.info(&#x27;Want:&#x27; + JSON.stringify(want)); try &#123; // 监听call事件所需的方法，对应call事件中的method字段 this.callee.on(&#x27;callFromCard&#x27;, callFromCard); &#125; catch (error) &#123; console.log(`callFromCard register failed with error $&#123;JSON.stringify(error)&#125;`) &#125;&#125;function callFromCard(data) &#123; // 获取call事件中传递的所有参数 let params = JSON.parse(data.readString()) if (params.formId !== undefined) &#123; let curFormId = params.formId; let message = params.detail; // 对应的自定义数据 &#x27;CallFromCard&#x27; console.info(`UpdateForm formId: $&#123;curFormId&#125;, message: $&#123;message&#125;`); // 可以进行相应的业务处理或者卡片刷新 // todo &#125; return null;&#125; message事件在卡片页面中可以通过postCardAction接口触发message事件拉起FormExtensionAbility。 1234567891011121314// 卡片页面postCardAction(this, &#123; &#x27;action&#x27;: &#x27;message&#x27;, &#x27;params&#x27;: &#123; &#x27;detail&#x27;: &#x27;messageEvent&#x27; &#125;&#125;);// FormAbility 中接受message事件，获取传递参数onFormEvent(formId, message) &#123; console.info(`FormAbility onEvent, formId = $&#123;formId&#125;, message: $&#123;JSON.stringify(message)&#125;`); // 可以进行相应的业务处理或者卡片刷新 // todo&#125;","tags":["鸿蒙","服务卡片"]},{"title":"CMakeList","path":"/2024/04/22/其他/CMakeList/","content":"一个跨平台的编译工具,可以用简单的语句来描述所有平台的编译过程。CMake能够输出makefile文件，然后系统会根据这个makefile文件内容编译整个工程。 Makefile是一个工程文件的编译规则，描述了整个工程的编译和链接规则。 基本语法格式：指令（参数1 参数2…）参数使用括号括起，参数之间使用空格或分号隔开，指令是大小写无关的，参数和变量是大小写相关的 123set(HELLO hello.cpp)add_excutable(hello main.cpp hello.cpp)ADD_EXECUTABLE(hello main.cpp $&#123;HELLO&#125;) 常用指令1.指定cmake的最小版本1cmake_minimum_required(VERSION 3.8) 2.设置项目名称1project(demo) 这个命令不是强制性的，但最好都加上。它会引入两个变量 demoBINARYDIR 和 demoSOURCEDIR，同时，CMake 自动定义了两个等价的变量 PROJECTBINARYDIR 和 PROJECTSOURCEDIR。 PROJECTBINARYDIR - 当前执行cmake路径 PROJECTSOURCEDIR - 源码最顶层CMakeLists.txt所在路径 3.设置编译模式12set(CMAKE_BUILD_TYPE &quot;Debug&quot;)set(CMAKE_BUILD_TYPE &quot;Release&quot;) 4.生成可执行文件1add_executable(demo demo.cpp) 5.生成一个静态&#x2F;动态&#x2F;模块库123add_library(common STATIC util.cpp test.cpp) #生成静态库add_libary(common SHARED util.cpp test.cpp) #生成动态库add_libary(common MODULE util.cpp test.cpp) #生成模块库 add_library默认生成静态库 6.设置目标库需要链接的依赖库1target_link_libraries(target lib1 lib2) 7.设置的包含目录12345include_directories( $&#123;CMAKE_CURRENT_SOURCE_DIR&#125; $&#123;CMAKE_CURRENT_BINARY_DIR&#125; $&#123;CMAKE_CURRENT_SOURCE_DIR&#125;/include) 8.设置链接库搜索目录1link_directories($&#123;CMAKE_CURRENT_SOURCE_DIR&#125;/lib) 9.消息输出1234message($&#123;PROJECT_SOURCE_DIR&#125;)message(&quot;build with debug mode&quot;)message(WARNING &quot;this is warning message&quot;)message(FATAL_ERROR &quot;this buld has man error&quot;) 10.搜索目录下所有的源代码文件，并将列表存储在一个变量中1auxsourcedirectory(dir VAR) dir：要搜索文件的目录VAR：存储搜索到的源代码文件列表的变量名 11.查找指定的库文件1find_library(VAR name path) 查找到指定的预编译库，并将它的路径存储在变量中类似的命令还有 findfile()、findpath()、findprogram()、findpackage() 12.设置变量123456// 设置变量set(VAR value)// 设置listset(LIST &#x27;item1&#x27; &#x27;item2&#x27; &#x27;item3&#x27;)// 删除变量unset(VAR)","tags":["编译","CMake"]},{"title":"Web组件","path":"/2024/04/13/鸿蒙/Web组件/","content":"使用web加载H5页面12345678webviewController: web_webview.WebviewController = new web_webview.WebviewController();// 加载网络页面Web(&#123; src: &#x27;www.example.com&#x27;, controller: this.webviewController&#125;)// 加载本地页面Web(&#123; src: $rawfile(&quot;local.html&quot;), controller: this.webviewController &#125;) Web组件上传文件Web组件支持前端页面选择文件上传功能，应用开发者可以使用onShowFileSelector()接口来处理前端页面文件上传的请求。当用户在前端页面点击文件上传按钮，应用侧在onShowFileSelector()接口中收到文件上传请求，在此接口中开发者将上传的本地文件路径设置给前端页面。 1234567891011Web(&#123; src: $rawfile(&#x27;local.html&#x27;), controller: this.controller &#125;) .onShowFileSelector((event) =&gt; &#123; // 开发者设置要上传的文件路径 let fileList: Array&lt;string&gt; = [ &#x27;xxx/test.png&#x27;, ] if(event)&#123; event.result.handleFileList(fileList) &#125; return true; &#125;) 应用侧调用前端页面函数应用侧可以通过runJavaScript()方法调用前端页面的JavaScript相关函数。 12345678Web(&#123; src: $rawfile(&#x27;index.html&#x27;), controller: this.webviewController&#125;)Button(&#x27;runJavaScript&#x27;) .onClick(() =&gt; &#123; // runJavaScript调用前端页面方法 this.webviewController.runJavaScript(&#x27;htmlTest()&#x27;);&#125;) 前端页面调用应用侧函数开发者使用Web组件将应用侧代码注册到前端页面中，注册完成之后，前端页面中使用注册的对象名称就可以调用应用侧的函数，实现在前端页面中调用应用侧方法。 注册应用侧代码有两种方式，一种在Web组件初始化使用调用，使用javaScriptProxy()接口。另外一种在Web组件初始化完成后调用，使用registerJavaScriptProxy()接口 12345678910111213141516// web组件加载本地index.html页面Web(&#123; src: $rawfile(&#x27;index.html&#x27;), controller: this.webviewController&#125;) // 将对象注入到web端 .javaScriptProxy(&#123; object: this.testObj, // 注入的对象 name: &quot;testObjName&quot;, // 对象名称 methodList: [&quot;test&quot;], // 需要注入的方法 controller: this.webviewController &#125;)Button(&#x27;Register JavaScript To Window&#x27;) .onClick(() =&gt; &#123; this.webviewController.registerJavaScriptProxy(this.testObj, &quot;testObjName&quot;, [&quot;test&quot;, &quot;toString&quot;]); // 使用registerJavaScriptProxy()接口注册方法时，注册后需调用refresh()接口生效。 this.webviewController.refresh(); &#125;) 建立应用侧与前端页面数据通道前端页面和应用侧之间可以用createWebMessagePorts()接口创建消息端口来实现两端的通信。 12345678910111213141516171819202122232425 // 1、创建两个消息端口。this.ports = this.controller.createWebMessagePorts(); // 2、在应用侧的消息端口(如端口1)上注册回调事件。this.ports[1].onMessageEvent((result: web_webview.WebMessage) =&gt; &#123; let msg = &#x27;Got msg from HTML:&#x27;; if (typeof(result) === &#x27;string&#x27;) &#123; console.info(`received string message from html5, string is: $&#123;result&#125;`); msg = msg + result; &#125; else if (typeof(result) === &#x27;object&#x27;) &#123; if (result instanceof ArrayBuffer) &#123; console.info(`received arraybuffer from html5, length is: $&#123;result.byteLength&#125;`); msg = msg + &#x27;lenght is &#x27; + result.byteLength; &#125; else &#123; console.info(&#x27;not support&#x27;); &#125; &#125; else &#123; console.info(&#x27;not support&#x27;); &#125; this.receivedFromHtml = msg;&#125;)// 3、将另一个消息端口(如端口0)发送到HTML侧，由HTML侧保存并使用。this.controller.postMessage(&#x27;__init_port__&#x27;, [this.ports[0]], &#x27;*&#x27;);// 4、使用应用侧的端口给另一个已经发送到html的端口发送消息。this.ports[1].postMessageEvent(this.sendFromEts); 123456789101112131415161718192021222324252627282930313233343536373839var h5Port;var output = document.querySelector(&#x27;.output&#x27;);window.addEventListener(&#x27;message&#x27;, function (event) &#123; if (event.data === &#x27;__init_port__&#x27;) &#123; if (event.ports[0] !== null) &#123; // 1. 保存从ets侧发送过来的端口 h5Port = event.ports[0]; h5Port.onmessage = function (event) &#123; // 2. 接收ets侧发送过来的消息. var msg = &#x27;Got message from ets:&#x27;; var result = event.data; if (typeof(result) === &#x27;string&#x27;) &#123; console.info(`received string message from html5, string is: $&#123;result&#125;`); msg = msg + result; &#125; else if (typeof(result) === &#x27;object&#x27;) &#123; if (result instanceof ArrayBuffer) &#123; console.info(`received arraybuffer from html5, length is: $&#123;result.byteLength&#125;`); msg = msg + &#x27;lenght is &#x27; + result.byteLength; &#125; else &#123; console.info(&#x27;not support&#x27;); &#125; &#125; else &#123; console.info(&#x27;not support&#x27;); &#125; output.innerHTML = msg; &#125; &#125; &#125;&#125;)// 3. 使用h5Port往ets侧发送消息.function PostMsgToEts(data) &#123; if (h5Port) &#123; h5Port.postMessage(data); &#125; else &#123; console.error(&#x27;h5Port is null, Please initialize first&#x27;); &#125;&#125;","tags":["鸿蒙","组件"]},{"title":"TS装饰器","path":"/2024/04/11/其他/TS装饰器/","content":"装饰器介绍装饰器（Decorator）是TS中的语法特性，用来对类进行装饰加工，可以被附加到类声明、属性、方法、访问器或参数等目标上。 装饰器本质是一个函数，比如一个装饰器名为decorator，以@decorator的形式使用。装饰器对目标的改变是在代码编译时发生的，编译后的代码中，定义被修饰目标时，装饰器函数会被调用，被装饰的目标的相关数据会被作为参数传入装饰器函数中。 类装饰器当装饰器用于修饰类时，装饰器应用于类的构造函数。装饰器函数会接受一个参数：target 即目标类的构造函数。可以返回一个新的类覆盖被装饰的类，如果不显式返回，则默认返回被装饰的类本身。 示例： 12345678910111213141516function classDecorator(target: Object) &#123; console.log(`target: $&#123;target&#125;`);&#125;@classDecoratorclass MyClass &#123; constructor() &#123; console.log(&#x27;MyClass constructor&#x27;); &#125; sayHello() &#123; console.log(&#x27;Hello&#x27;); &#125;&#125;const myClass = new MyClass();myClass.sayHello(); 执行结果： 12345678910target: class MyClass &#123; constructor() &#123; console.log(&#x27;MyClass constructor&#x27;); &#125; sayHello() &#123; console.log(&#x27;Hello&#x27;); &#125;&#125;MyClass constructorHello 方法装饰器使用装饰器装饰类的方法时，装饰器函数可以接收三个参数： target：装饰器的目标对象，对于静态方法是类的构造函数，对于实例方法是类的原型对象。 propertyKey：方法的名字。 descriptor：属性描述。descriptor 是一个对象，包含了目标方法或属性的各种属性和配置。它是内置的PropertyDescriptor 类型. 如果有返回值，则会作为目标方法的属性描述符。 示例： 12345678910111213141516171819function methodDecorator(target: Object, propertyKey: string | symbol, descriptor: PropertyDescriptor) &#123; console.log(&#x27;target:&#x27;, target); console.log(&#x27;propertyKey&#x27;, propertyKey); console.log(&#x27;descriptor&#x27;, descriptor);&#125;class MyClass &#123; constructor() &#123; console.log(&#x27;MyClass constructor&#x27;); &#125; @methodDecorator sayHello() &#123; console.log(&#x27;Hello&#x27;); &#125;&#125;const myClass = new MyClass();myClass.sayHello(); 执行结果： 12345678910target: &#123;&#125;propertyKey sayHellodescriptor &#123; value: [Function: sayHello], writable: true, enumerable: false, configurable: true&#125;MyClass constructorHello 有返回值示例： 123456789101112131415161718192021222324function methodDecorator(target: Object, propertyKey: string | symbol, descriptor: PropertyDescriptor) &#123; const func = descriptor.value; descriptor.value = () =&gt; &#123; console.log(&#x27;say hello start&#x27;); func(); console.log(&#x27;say hello end&#x27;); &#125;; return descriptor;&#125;class MyClass &#123; constructor() &#123; console.log(&#x27;MyClass constructor&#x27;); &#125; @methodDecorator sayHello() &#123; console.log(&#x27;Hello&#x27;); &#125;&#125;const myClass = new MyClass();myClass.sayHello(); 执行结果： 1234MyClass constructorsay hello startHellosay hello end 属性装饰器装饰器装饰属性时，接收两个参数： target: 静态属性时类的构造函数，实例属性是类的原型对象。 propertyKey: 属性名。 属性装饰器的返回值会被忽略。 由于TS没有办法在定义一个原型对象的成员变量是描述一个实例属性，并且没办法监视或修改一个数下的初始化方法，所以属性描述符不会作为参数被传入属性装饰器。因此属性修饰器的智能监视类中是否声明了某个名字的属性。 示例： 123456789101112function PropertyDescriptor(target: Object, propertyKey: string | symbol) &#123; console.log(&#x27;target&#x27;, target); console.log(&#x27;propertyKey&#x27;, propertyKey);&#125;class MyClass &#123; @PropertyDescriptor name: string = &#x27;xiaoli&#x27;;&#125;const myClass = new MyClass(); 执行结果： 12target &#123;&#125;propertyKey name 参数装饰器参数装饰器接收三个参数：target: 静态属性时类的构造函数，实例属性是类的原型对象。。propertyKey:表示被装饰的方法的名称。parameterIndex: 表示被装饰的参数在方法参数列表中的索引。 参数装饰器的返回值会被忽略。 示例： 1234567891011121314function ParamDecorator(target: Object, propertyKey: string, parameterIndex: number) &#123; console.log(&#x27;target&#x27;, target); console.log(&#x27;propertyKey&#x27;, propertyKey); console.log(&#x27;parameterIndex&#x27;, parameterIndex);&#125;class MyClass &#123; say(@ParamDecorator name: string, @ParamDecorator age: number) &#123; console.log(&#x27;my name is:&#x27; + name, age + &#x27;years old&#x27;); &#125;&#125;const myClass = new MyClass();myClass.say(&#x27;xiaoli&#x27;, 18); 执行结果： 1234567target &#123;&#125;propertyKey say parameterIndex 1target &#123;&#125; propertyKey say parameterIndex 0my name is:xiaoli 18years old 访问器装饰器访问器装饰器的参数与方法装饰器一致。 注意：不能同时装饰一个成员变量的get和set方法，当装饰一个访问器时，因为装饰器应用与一个属性描述符时，它联合了属性的get方法和set方法。 示例： 12345678910111213141516171819202122232425function VisitorDecorator(target: Object, propertyKey: string, descriptor: PropertyDescriptor) &#123; console.log(&#x27;target&#x27;, target); console.log(&#x27;propertyKey&#x27;, propertyKey); console.log(&#x27;descriptor&#x27;, descriptor);&#125;class MyClass &#123; private _name: string; constructor(name: string) &#123; this._name = name; &#125; @VisitorDecorator get name() &#123; return this._name; &#125; set name(value: string) &#123; this._name = value; &#125;&#125;const myClass = new MyClass(&#x27;xiaoli&#x27;); 执行结果： 12345678target &#123;&#125;propertyKey namedescriptor &#123; get: [Function: get name], set: [Function: set name], enumerable: false, configurable: true&#125; 装饰器工厂装饰器是用于返回一个装饰器的工厂函数。以@DecoratorFactory(args)形式调用。 示例： 1234567891011121314151617181920212223function Decoratorfactory(prefix: string) &#123; return function (target: Object, propertyKey: string, descriptor: PropertyDescriptor) &#123; const func = descriptor.value; descriptor.value = () =&gt; &#123; console.log(&#x27;factoy:&#x27;, prefix); func(); &#125;; return descriptor; &#125;&#125;class MyClass &#123; @Decoratorfactory(&#x27;hello&#x27;) say() &#123; console.log(&#x27;my name is xiaoli&#x27;); &#125;&#125;const myClass = new MyClass();myClass.say(); 执行结果 12factoy: hellomy name is xiaoli","tags":["TypeScript","装饰器"]}]